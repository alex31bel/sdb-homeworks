# Домашнее задание к занятию «Индексы»

### Задание 1

Напишите запрос к учебной базе данных, который вернёт процентное отношение общего размера всех индексов к общему размеру всех таблиц.


<ins>**Ответ:**</ins>
```sql
SELECT (SUM(INDEX_LENGTH)/SUM(DATA_LENGTH))*100 AS 'INDEX/DATA'
FROM information_schema.TABLES t;
```
Скриншот-1 к заданию 1:

![Скриншот-1](https://github.com/alex31bel/sdb-homeworks/blob/main/img/12-5-1-1.PNG)


### Задание 2

Выполните explain analyze следующего запроса:
```sql
select distinct concat(c.last_name, ' ', c.first_name), sum(p.amount) over (partition by c.customer_id, f.title)
from payment p, rental r, customer c, inventory i, film f
where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id
```
- перечислите узкие места;
- оптимизируйте запрос: внесите корректировки по использованию операторов, при необходимости добавьте индексы.


<ins>**Ответ:**</ins>

Скриншот-1 к заданию 2:

![Скриншот-1](https://github.com/alex31bel/sdb-homeworks/blob/main/img/12-5-2-1.PNG)

Убираем чтение лишнего столбца title из таблици film и сокращаем выполнения с time=12308 до time=22.5.
```sql
select distinct concat(c.last_name, ' ', c.first_name), sum(p.amount) over (partition by c.customer_id)
from payment p, rental r, customer c, inventory i
where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id
```
Скриншот-2 к заданию 2:

![Скриншот-2](https://github.com/alex31bel/sdb-homeworks/blob/main/img/12-5-2-2.PNG)



## Дополнительные задания (со звёздочкой*)
Эти задания дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже шире разобраться в материале.

### Задание 3*

Самостоятельно изучите, какие типы индексов используются в PostgreSQL. Перечислите те индексы, которые используются в PostgreSQL, а в MySQL — нет.

*Приведите ответ в свободной форме.*


<ins>**Ответ:**</ins>

- **GIN-индексы** (Generalized Inverted Index) представляют собой «инвертированные индексы», в которых могут содержаться значения с несколькими ключами, например массивы. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно работать в запросах, проверяющих присутствие определённых значений компонентов.
- **GiST-индексы** (Generalized Search Tree) представляют собой не просто разновидность индексов, а инфраструктуру, позволяющую реализовать много разных стратегий индексирования. Как следствие, GiST-индексы могут применяться с разными операторами, в зависимости от стратегии индексирования (класса операторов).
- **Индексы SP-GiST** (Space-Partitioned Generalized Search Tree), как и GiST, предоставляют инфраструктуру, поддерживающую различные типы поиска. SP-GiST позволяет организовывать на диске самые разные несбалансированные структуры данных, такие как деревья квадрантов, k-мерные и префиксные деревья.
- **BRIN-индексы** (Block Range INdexes) хранят обобщённые сведения о значениях, находящихся в физически последовательно расположенных блоках таблицы. Подобно GiST, SP-GiST и GIN, индексы BRIN могут поддерживать определённые пользователем стратегии, и в зависимости от них применяться с разными операторами.
- **Hash-индексы** хранят 32-битный хеш-код, полученный из значения индексированного столбца, поэтому хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором =.
- **RUM** (Range-UpperMark) - это индекс, который используется для поиска по диапазону значений с возможностью оптимизации для запросов, которые содержат частичное совпадение.
- **KNN-GiST** (K-nearest neighbor search) - это индекс, который используется для поиска ближайших соседей на плоскости или в пространстве.